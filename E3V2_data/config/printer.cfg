[include shell_command.cfg]
[include mainsail.cfg]

[virtual_sdcard]
path: /home/pi/E3V2_data/gcodes
on_error_gcode: CANCEL_PRINT

# All customizations are documented in globals.cfg. Just copy a variable from
# there into the section below, and change the value to meet your needs.

[gcode_macro _km_options]
# These are examples of some likely customizations:
# Any sheets in the below list will be available with a configurable offset.
#variable_bed_surfaces: ['smooth_1','texture_1']
# Length (in mm) of filament to load (bowden tubes will be longer).
variable_load_length: 50.0
# Additional padding around the specified print area for a bed mesh.
variable_probe_mesh_padding : 5.0
# Minimum number of probes for partial probing of a bed mesh.
variable_probe_min_count: 4
# Scaling factor to increase probe count for partial bed probes.
variable_probe_count_scale: 1.5
# Hide the Octoprint LCD menu since I don't use it.
#variable_menu_show_octoprint: False
# Customize the filament menus (up to 10 entries).
variable_menu_temperature: [
  {'name' : 'PLA',  'extruder' : 200.0, 'bed' : 60.0},
  {'name' : 'PETG', 'extruder' : 230.0, 'bed' : 85.0},
  {'name' : 'ABS',  'extruder' : 245.0, 'bed' : 110.0}]
# Extruder scale factor during pre-warmup in PRINT_START.
variable_start_extruder_preheat_scale: 1
# Additional delay (in ms) during bed heating, to allow the bed to stabilize.
variable_start_bed_heat_delay: 1000
# Amount (in degrees C) to overshoot bed target temp before stabilizing.
variable_start_bed_heat_overshoot: 1
# Length of filament (in millimeters) to purge at print start.
variable_start_purge_length: 30 # This value works for most setups.

gcode: # This line is required by Klipper.
# Any code you put here will run at klipper startup, after the initialization
# for these macros. For example, you could uncomment the following line to
# automatically adjust your bed surface offsets to account for any changes made
# to your Z endstop or probe offset.
#  ADJUST_SURFACE_OFFSETS

# This line includes all the standard macros.
[include klipper-macros/*.cfg]
# Uncomment to include features that require specific hardware support.
# LCD menu support for features like bed surface selection and pause next layer.
#[include klipper-macros/optional/lcd_menus.cfg]
# Optimized bed leveling
[include klipper-macros/optional/bed_mesh.cfg]

# The sections below here are required for the macros to work.
[idle_timeout]
gcode:
  _KM_IDLE_TIMEOUT

[pause_resume]

[respond]

[save_variables]
filename: ~/E3V2_data/variables.cfg # UPDATE THIS FOR YOUR PATH!!!

[display_status]

# This file contains pin mappings for the stock 2020 Creality Ender 3
# V2. To use this config, during "make menuconfig" select the
# STM32F103 with a "28KiB bootloader" and serial (on USART1 PA10/PA9)
# communication.

# If you prefer a direct serial connection, in "make menuconfig"
# select "Enable extra low-level configuration options" and select
# serial (on USART3 PB11/PB10), which is broken out on the 10 pin IDC
# cable used for the LCD module as follows:
# 3: Tx, 4: Rx, 9: GND, 10: VCC

# Flash this firmware by copying "out/klipper.bin" to a SD card and
# turning on the printer with the card inserted. The firmware
# filename must end in ".bin" and must not match the last filename
# that was flashed.

# See docs/Config_Reference.md for a description of parameters.

# Max print dimensions xyz in mm: 227*223*230mm
# Max Movement dimensions xyz in mm: (0to249)*(-8to222)*(max_z247)

[tmc2208 stepper_x]
uart_pin: PA14
#   The pin connected to the TMC2208 PDN_UART line. This parameter
#   must be provided.
#tx_pin:
#   If using separate receive and transmit lines to communicate with
#   the driver then set uart_pin to the receive pin and tx_pin to the
#   transmit pin. The default is to use uart_pin for both reading and
#   writing.
#select_pins:
#   A comma separated list of pins to set prior to accessing the
#   tmc2208 UART. This may be useful for configuring an analog mux for
#   UART communication. The default is to not configure any pins.
#interpolate: False
#   If true, enable step interpolation (the driver will internally
#   step at a rate of 256 micro-steps). This interpolation does
#   introduce a small systemic positional deviation - see
#   TMC_Drivers.md for details. The default is True.
run_current: 0.59 #max 0.84A for xyzz1 motors
#   The amount of current (in amps RMS) to configure the driver to use
#   during stepper movement. This parameter must be provided.
#hold_current:
#   The amount of current (in amps RMS) to configure the driver to use
#   when the stepper is not moving. Setting a hold_current is not
#   recommended (see TMC_Drivers.md for details). The default is to
#   not reduce the current.
sense_resistor: 0.150
#   The resistance (in ohms) of the motor sense resistor. The default
#   is 0.110 ohms.
#stealthchop_threshold: 999999
#   The velocity (in mm/s) to set the "stealthChop" threshold to. When
#   set, "stealthChop" mode will be enabled if the stepper motor
#   velocity is below this value. The default is 0, which disables
#   "stealthChop" mode.
#driver_IHOLDDELAY: 8
#driver_TPOWERDOWN: 20
#driver_TBL: 2
#driver_TOFF: 3
#driver_HEND: 0
#driver_HSTRT: 5
#driver_PWM_AUTOGRAD: True
#driver_PWM_AUTOSCALE: True
#driver_PWM_LIM: 12
#driver_PWM_REG: 8
#driver_PWM_FREQ: 1
#driver_PWM_GRAD: 14
#driver_PWM_OFS: 36
#   Set the given register during the configuration of the TMC2208
#   chip. This may be used to set custom motor parameters. The
#   defaults for each parameter are next to the parameter name in the
#   above list.

[tmc2208 stepper_y]
uart_pin: PA3
#interpolate: False
run_current: 0.59
#stealthchop_threshold: 999999
sense_resistor: 0.150

[tmc2208 stepper_z]
uart_pin: PA13
#interpolate: False
run_current: 0.55
#stealthchop_threshold: 999999
sense_resistor: 0.150

[tmc2208 stepper_z1]
uart_pin: PA7
#interpolate: False
run_current: 0.55
#stealthchop_threshold: 999999
sense_resistor: 0.150

[tmc2209 extruder]
uart_pin: PC6
#tx_pin:
#select_pins:
#interpolate: False 
run_current: 0.55 #max 1.0A for E motor 
#hold_current:
sense_resistor: 0.110
#stealthchop_threshold: 999999
#   See the "tmc2208" section for the definition of these parameters.
#uart_address: 0
#   The address of the TMC2209 chip for UART messages (an integer
#   between 0 and 3). This is typically used when multiple TMC2209
#   chips are connected to the same UART pin. The default is zero.
#driver_IHOLDDELAY: 8
#driver_TPOWERDOWN: 20
#driver_TBL: 2
#driver_TOFF: 3
#driver_HEND: 0
#driver_HSTRT: 5
#driver_PWM_AUTOGRAD: True
#driver_PWM_AUTOSCALE: True
#driver_PWM_LIM: 12
#driver_PWM_REG: 8
#driver_PWM_FREQ: 1
#driver_PWM_GRAD: 14
#driver_PWM_OFS: 36
#driver_SGTHRS: 0
#   Set the given register during the configuration of the TMC2209
#   chip. This may be used to set custom motor parameters. The
#   defaults for each parameter are next to the parameter name in the
#   above list.
#diag_pin:
#   The micro-controller pin attached to the DIAG line of the TMC2209
#   chip. The pin is normally prefaced with "^" to enable a pullup.
#   Setting this creates a "tmc2209_stepper_x:virtual_endstop" virtual
#   pin which may be used as the stepper's endstop_pin. Doing this
#   enables "sensorless homing". (Be sure to also set driver_SGTHRS to
#   an appropriate sensitivity value.) The default is to not enable
#   sensorless homing.

[temperature_sensor mcu_temp]
sensor_type: temperature_mcu
min_temp: 0
max_temp: 80

[temperature_sensor raspberry_pi]
sensor_type: temperature_host
min_temp: 0
max_temp: 80

[stepper_x]
step_pin: PC2
#   Step GPIO pin (triggered high). This parameter must be provided.
dir_pin: PB9
#   Direction GPIO pin (high indicates positive direction). This
#   parameter must be provided.
enable_pin: !PC3
#   Enable pin (default is enable high; use ! to indicate enable
#   low). If this parameter is not provided then the stepper motor
#   driver must always be enabled.
rotation_distance: 40
#   Distance (in mm) that the axis travels with one full rotation of
#   the stepper motor (or final gear if gear_ratio is specified).
#   This parameter must be provided.
microsteps: 16
#   The number of microsteps the stepper motor driver uses. This
#   parameter must be provided.
#full_steps_per_rotation: 200
#   The number of full steps for one rotation of the stepper motor.
#   Set this to 200 for a 1.8 degree stepper motor or set to 400 for a
#   0.9 degree motor. The default is 200.
#gear_ratio:
#   The gear ratio if the stepper motor is connected to the axis via a
#   gearbox. For example, one may specify "5:1" if a 5 to 1 gearbox is
#   in use. If the axis has multiple gearboxes one may specify a comma
#   separated list of gear ratios (for example, "57:11, 2:1"). If a
#   gear_ratio is specified then rotation_distance specifies the
#   distance the axis travels for one full rotation of the final gear.
#   The default is to not use a gear ratio.
#step_pulse_duration:
#   The minimum time between the step pulse signal edge and the
#   following "unstep" signal edge. This is also used to set the
#   minimum time between a step pulse and a direction change signal.
#   The default is 0.000000100 (100ns) for TMC steppers that are
#   configured in UART or SPI mode, and the default is 0.000002 (which
#   is 2us) for all other steppers.
endstop_pin: ^PA5
#   Endstop switch detection pin. If this endstop pin is on a
#   different mcu than the stepper motor then it enables "multi-mcu
#   homing". This parameter must be provided for the X, Y, and Z
#   steppers on cartesian style printers.
position_min: -13
#   Minimum valid distance (in mm) the user may command the stepper to
#   move to.  The default is 0mm.
position_endstop: -13
#   Location of the endstop (in mm). This parameter must be provided
#   for the X, Y, and Z steppers on cartesian style printers.
position_max: 236
#   Maximum valid distance (in mm) the user may command the stepper to
#   move to. This parameter must be provided for the X, Y, and Z
#   steppers on cartesian style printers.
homing_speed: 35
#   Maximum velocity (in mm/s) of the stepper when homing. The default
#   is 5mm/s.
#homing_retract_dist: 5.0
#   Distance to backoff (in mm) before homing a second time during
#   homing. Set this to zero to disable the second home. The default
#   is 5mm.
#homing_retract_speed:
#   Speed to use on the retract move after homing in case this should
#   be different from the homing speed, which is the default for this
#   parameter
#second_homing_speed:
#   Velocity (in mm/s) of the stepper when performing the second home.
#   The default is homing_speed/2.
#homing_positive_dir:
#   If true, homing will cause the stepper to move in a positive
#   direction (away from zero); if false, home towards zero. It is
#   better to use the default than to specify this parameter. The
#   default is true if position_endstop is near position_max and false
#   if near position_min.

[stepper_y]
step_pin: PB8
dir_pin: PB7
enable_pin: !PC3
microsteps: 16
rotation_distance: 40
endstop_pin: ^PA6
position_endstop: -13
position_max: 217
position_min: -13
homing_speed: 35

[stepper_z]
step_pin: PB6
dir_pin: !PB5
enable_pin: !PC3
microsteps: 16
rotation_distance: 8
endstop_pin: probe:z_virtual_endstop
position_max: 247
position_min: -5

[stepper_z1]
step_pin: PB4
dir_pin: !PB3
enable_pin: !PC3
microsteps: 16
rotation_distance: 8
#   See the "stepper" section for the definition of the above parameters.
#endstop_pin:
#   If an endstop_pin is defined for the additional stepper then the
#   stepper will home until the endstop is triggered. Otherwise, the
#   stepper will home until the endstop on the primary stepper for the
#   axis is triggered.

[extruder]
max_extrude_only_distance: 300
step_pin: PB11
dir_pin: PB10
enable_pin: !PB2
microsteps: 16
rotation_distance: 24.695
nozzle_diameter: 0.6000
filament_diameter: 1.750
heater_pin: PA1
sensor_type: BIQU NTC100K
sensor_pin: PC5
gear_ratio: 7:1
min_temp: 0
max_temp: 350
#pressure_advance: 0.057
#min_extrude_temp: 12

[thermistor BIQU NTC100K]

## values calibrated against a PT100 reference

temperature1: 25.0

resistance1: 103180.0

temperature2: 150.0

resistance2: 1366.2

temperature3: 250.0

resistance3: 168.6

[bltouch]
sensor_pin: ^PB1
control_pin: PB0
x_offset: 60.5
y_offset: 2.5
pin_move_time: 0.5

[safe_z_home]
home_xy_position: 55,106 #print area x:(231/2)-60.5 y:(217/2)-2.5 i.e. in the middle of the printing area
speed: 200
z_hop: 5
z_hop_speed: 10

[bed_mesh]
speed: 150
horizontal_move_z: 5
mesh_min: 47.5,0
mesh_max: 231,217
probe_count: 5,5
algorithm: bicubic
fade_start: 1
fade_end: 10
fade_target: 0

[screws_tilt_adjust]
screw1: 32, 32
screw1_name: Front left
screw2: 171, 32
screw2_name: Front right
screw3: 171, 171
screw3_name: Back right
screw4: 32, 171
screw4_name: Back left
screw_thread: CW-M4
speed: 120
horizontal_move_z: 5

# screws on an Ender 3 V2 are offset by 32mm from the edges of the 235mm bed

[heater_bed]
heater_pin: PA2
sensor_type: EPCOS 100K B57560G104F
sensor_pin: PC4
min_temp: 0
max_temp: 130

[fan]
pin: PA0

[filament_switch_sensor Filament_runout_sensor]
pause_on_runout: True
runout_gcode:
  G91
  G1 Z20 F900      # Raise Z away from print
  G90
  G1 X245 Y218.5 F5000 # Move to purge area
  G91
  G1 E-150 F600 # Retract 150mm of filament
  G90
insert_gcode:
  G4 P10000 # Pause for 10 seconds
  G1 E150 F400 # Prime the nozzle
switch_pin:!PA4 # Pin that the sensor is connected to

[mcu]
serial: /dev/serial/by-path/platform-fd500000.pcie-pci-0000:01:00.0-usb-0:1.3:1.0-port0
restart_method: command

#[mcu rpi]
#serial: /tmp/klipper_host_mcu

#[adxl345 x]
#cs_pin: rpi:None
# #   The SPI enable pin for the sensor. This parameter must be provided.
# #spi_speed: 5000000
# #   The SPI speed (in hz) to use when communicating with the chip.
# #   The default is 5000000.
# #spi_bus:
# #spi_software_sclk_pin:
# #spi_software_mosi_pin:
# #spi_software_miso_pin:
# #   See the "common SPI settings" section for a description of the
# #   above parameters.
#axes_map: -y, -x, z
# #   The accelerometer axis for each of the printer's X, Y, and Z axes.
# #   This may be useful if the accelerometer is mounted in an
# #   orientation that does not match the printer orientation. For
# #   example, one could set this to "y, x, z" to swap the X and Y axes.
# #   It is also possible to negate an axis if the accelerometer
# #   direction is reversed (eg, "x, z, -y"). The default is "x, y, z".
# #rate: 3200
# #   Output data rate for ADXL345. ADXL345 supports the following data
# #   rates: 3200, 1600, 800, 400, 200, 100, 50, and 25. Note that it is
# #   not recommended to change this rate from the default 3200, and
# #   rates below 800 will considerably affect the quality of resonance
# #   measurements.

#[mpu9250 y]
# #i2c_address:
# #   Default is 104 (0x68). If AD0 is high, it would be 0x69 instead.
#i2c_mcu: rpi
#i2c_bus: i2c.1
# #i2c_speed: 400000
# #   See the "common I2C settings" section for a description of the
# # #   above parameters. The default "i2c_speed" is 400000.
#axes_map: -x, y, z
# # #   See the "adxl345" section for information on this parameter.


#[resonance_tester]
#probe_points: 115.5, 108.5, 50  #x, y, z
# #   A list of X, Y, Z coordinates of points (one point per line) to test
# #   resonances at. At least one point is required. Make sure that all
# #   points with some safety margin in XY plane (~a few centimeters)
# #   are reachable by the toolhead.
# #accel_chip:
# #   A name of the accelerometer chip to use for measurements. If
# #   adxl345 chip was defined without an explicit name, this parameter
# #   can simply reference it as "accel_chip: adxl345", otherwise an
# #   explicit name must be supplied as well, e.g. "accel_chip: adxl345
# #   my_chip_name". Either this, or the next two parameters must be
# #   set.
#accel_chip_x: adxl345 x
#accel_chip_y: mpu9250 y
# #   Names of the accelerometer chips to use for measurements for each
# #   of the axis. Can be useful, for instance, on bed slinger printer,
# #   if two separate accelerometers are mounted on the bed (for Y axis)
# #   and on the toolhead (for X axis). These parameters have the same
# #   format as 'accel_chip' parameter. Only 'accel_chip' or these two
# #   parameters must be provided.
# #max_smoothing:
# #   Maximum input shaper smoothing to allow for each axis during shaper
# #   auto-calibration (with 'SHAPER_CALIBRATE' command). By default no
# #   maximum smoothing is specified. Refer to Measuring_Resonances guide
# #   for more details on using this feature.
# #min_freq: 5
# #   Minimum frequency to test for resonances. The default is 5 Hz.
# #max_freq: 133.33
# #   Maximum frequency to test for resonances. The default is 133.33 Hz.
# #accel_per_hz: 75
# #   This parameter is used to determine which acceleration to use to
# #   test a specific frequency: accel = accel_per_hz * freq. Higher the
# #   value, the higher is the energy of the oscillations. Can be set to
# #   a lower than the default value if the resonances get too strong on
# #   the printer. However, lower values make measurements of
# #   high-frequency resonances less precise. The default value is 75
# #   (mm/sec).
# #hz_per_sec: 1
# #   Determines the speed of the test. When testing all frequencies in
# #   range [min_freq, max_freq], each second the frequency increases by
# #   hz_per_sec. Small values make the test slow, and the large values
# #   will decrease the precision of the test. The default value is 1.0
# #   (Hz/sec == sec^-2).

[input_shaper]
#shaper_freq_x: 103.4
#   A frequency (in Hz) of the input shaper for X axis. This is
#   usually a resonance frequency of X axis that the input shaper
#   should suppress. For more complex shapers, like 2- and 3-hump EI
#   input shapers, this parameter can be set from different
#   considerations. The default value is 0, which disables input
#   shaping for X axis.
#shaper_freq_y: 49.0
#   A frequency (in Hz) of the input shaper for Y axis. This is
#   usually a resonance frequency of Y axis that the input shaper
#   should suppress. For more complex shapers, like 2- and 3-hump EI
#   input shapers, this parameter can be set from different
#   considerations. The default value is 0, which disables input
#   shaping for Y axis.
#shaper_type: ei
#   A type of the input shaper to use for both X and Y axes. Supported
#   shapers are zv, mzv, zvd, ei, 2hump_ei, and 3hump_ei. The default
#   is mzv input shaper.
#shaper_type_x:
#shaper_type_y:
#   If shaper_type is not set, these two parameters can be used to
#   configure different input shapers for X and Y axes. The same
#   values are supported as for shaper_type parameter.
#damping_ratio_x: 0.1
#damping_ratio_y: 0.1
#   Damping ratios of vibrations of X and Y axes used by input shapers
#   to improve vibration suppression. Default value is 0.1 which is a
#   good all-round value for most printers. In most circumstances this
#   parameter requires no tuning and should not be changed.

[printer]
kinematics: cartesian
max_velocity: 500
max_accel: 5000
max_z_velocity: 10
max_z_accel: 100

[exclude_object]

# link https://klipper.discourse.group/t/firmware-retraction-z-hop/2662?page=2

[firmware_retraction]
retract_length: 2
#   The length of filament (in mm) to retract when G10 is activated,
#   and to unretract when G11 is activated (but see
#   unretract_extra_length below). The default is 0 mm.
retract_speed: 60
#   The speed of retraction, in mm/s. The default is 20 mm/s.
unretract_extra_length: 0
#   The length (in mm) of *additional* filament to add when
#   unretracting.
unretract_speed: 40
#   The speed of unretraction, in mm/s. The default is 10 mm/s.


[gcode_arcs]
#If you allready have this somewhere you will need to remove it here or there


[gcode_macro G0]
rename_existing: G0.1
gcode:
  G1 {rawparams}

[gcode_macro G1]
rename_existing: G1.1
variable_z_hop_offset = 0
gcode:
  {% set OFFSET = printer["gcode_macro G1"].z_hop_offset %}
  {% if printer.gcode_move.absolute_coordinates and OFFSET > 0 and ('Z' in params) %}
    ; Rewrite paramters for adjust Z if offset is activ and we are absulute
    {% set new_params = ''|string %}
    {% if ('E' in params) %}
      {% set new_params = new_params ~ " E" ~ params.E %}
    {% endif %}
  
    {% if ('F' in params) %}
      {% set new_params = new_params ~ " F" ~ params.F %}
    {% endif %}
  
    {% if ('X' in params) %}
      {% set new_params = new_params ~ " X" ~ params.X %}
    {% endif %}
  
    {% if ('Y' in params) %}
      {% set new_params = new_params ~ " Y" ~ params.Y %}
    {% endif %}
  
    
    {% set new_params = new_params ~ (' Z%g' % (params.Z|float + OFFSET))|string %}
    
    ; Make the movement
    G1.1{new_params}
  {% else %}
    ; Don't care if relativ or no offset activ
    G1.1 {rawparams}
  {% endif %}


[gcode_macro G2]
rename_existing: G2.1
gcode:
  {% set OFFSET = printer["gcode_macro G1"].z_hop_offset %}
  {% if printer.gcode_move.absolute_coordinates and OFFSET > 0 and ('Z' in params) %}
    ; Rewrite paramters for adjust Z if offset is activ and we are absulute

    {% set new_params = [] %}
    {% for key in params %}
      {% if key == "Z" %}
        {% set x = new_params.append('Z%g' % (params[key]|float + OFFSET)) %}
      {% else %}
        {% set x = new_params.append(key + params[key]) %}
      {% endif %}
    {% endfor %}

    {% set new_params=new_params|join(" ") %}

    ; Make the movement
    G2.1 {new_params}
  {% else %}
    ; Don't care if relativ or no offset activ
    G2.1 {rawparams}
  {% endif %}

[gcode_macro G3]
rename_existing: G3.1
gcode:
  {% set OFFSET = printer["gcode_macro G1"].z_hop_offset %}
  {% if printer.gcode_move.absolute_coordinates and OFFSET > 0 and ('Z' in params) %}
    ; Rewrite paramters for adjust Z if offset is activ and we are absulute

    {% set new_params = [] %}
    {% for key in params %}
      {% if key == "Z" %}
        {% set x = new_params.append('Z%g' % (params[key]|float + OFFSET)) %}
      {% else %}
        {% set x = new_params.append(key + params[key]) %}
      {% endif %}
    {% endfor %}

    {% set new_params=new_params|join(" ") %}

    ; Make the movement
    G3.1 {new_params}
  {% else %}
    ; Don't care if relativ or no offset activ
    G3.1 {rawparams}
  {% endif %}

# Hacked G11 (unretract) for have a short delay after unretract, remove it or set wait to 0, if this is not needed.
[gcode_macro G11]
rename_existing: G11.1
gcode:
  {% set OFFSET = printer["gcode_macro G1"].z_hop_offset %}
  ; Z-UNHOP
  {% if OFFSET > 0 %}
    {% set VELOCITY = printer.save_variables.variables.current_zhop_velocity|default(300)|float %}
    SET_GCODE_VARIABLE MACRO=G1 VARIABLE=z_hop_offset VALUE=0
    {% set speed = printer.gcode_move.speed %}
    ; Make a different movement coresponting to current coordinate mode
    {% if printer.gcode_move.absolute_coordinates %}
      #G1.1 F{VELOCITY} Z{(printer.gcode_move.position.z - OFFSET)}
      G91
      G1.1 Z-{OFFSET} F{VELOCITY}
      G90
    {% else %}
      G1.1 Z-{OFFSET} F{VELOCITY}
    {% endif %}
    G1.1 F{speed}
  {% endif %}

  G11.1
  ; Have an addional parameter for wait after unretract
  {% set wait = printer.save_variables.variables.current_unretract_wait|default(0)|float %}
  {% if wait > 0 %}
    G4 P{'%d' %wait}
  {% endif %}

# Hacked G10 (retract) with ZHOP
[gcode_macro G10]
rename_existing: G10.1
gcode:
  {% set OFFSET = printer["gcode_macro G1"].z_hop_offset %}
  ; Make the retract
  G10.1

  ; Make the ZHOP
  {% set HEIGHT = printer.save_variables.variables.current_zhop_height|default(0)|float %}

  {% if HEIGHT > 0 %}
    {% if OFFSET > 0 %}
      SHOW_MSG MSG="ZHOP allready activ"
    {% else %}
      {% set VELOCITY = printer.save_variables.variables.current_zhop_velocity|default(300)|float %}
      {% set speed = printer.gcode_move.speed %}
      SET_GCODE_VARIABLE MACRO=G1 VARIABLE=z_hop_offset VALUE={HEIGHT}
      ; Make a different movement coresponting to current coordinate mode
      {% if printer.gcode_move.absolute_coordinates %}
        #SHOW_MSG MSG="G10 abs up: {(printer.gcode_move.position.z + HEIGHT)}"
        #G1.1 Z{(printer.gcode_move.position.z + HEIGHT)} F{VELOCITY}
        G91
        G1.1 Z{HEIGHT} F{VELOCITY}
        G90
      {% else %}
        G1.1 Z{HEIGHT} F{VELOCITY}
      {% endif %}
      G1.1 F{speed}
    {% endif %}
  {% endif %}


# Set the wished ZHOP height/distance. Set to 0 will disable it!
[gcode_macro SET_ZHOP]
gcode:
  {% set HEIGHT = params.HEIGHT|default(0)|float %}
  {% set VELOCITY = params.VELOCITY|default(300)|float %}
  {% if VELOCITY > 0 %}
    SAVE_VARIABLE VARIABLE='current_zhop_velocity' VALUE={VELOCITY}
  {% endif %}
  {% if HEIGHT >= 0 %}
    SAVE_VARIABLE VARIABLE='current_zhop_height' VALUE={HEIGHT}
    SHOW_MSG MSG="ZHOP: Z{HEIGHT}/F{VELOCITY}"
  {% endif %}

# This should allways be part of the start gcode. Worestcase you will print with an positive offset.
[gcode_macro CLEAR_ZHOP]
gcode:
  SET_GCODE_VARIABLE MACRO=G1 VARIABLE=z_hop_offset VALUE=0

# Print ZHOP settings
[gcode_macro GET_ZHOP]
gcode:
  {% set HEIGHT = printer.save_variables.variables.current_zhop_height|default(0)|float %}
  {% set VELOCITY = printer.save_variables.variables.current_zhop_velocity|default(300)|float %}
  {% set OFFSET = printer["gcode_macro G1"].z_hop_offset %}
  SHOW_MSG MSG="ZHOP height:    {HEIGHT}"
  SHOW_MSG MSG="ZHOP velocity:  {VELOCITY}"
  SHOW_MSG MSG="ZHOP retracted: {'yes' if (OFFSET > 0) else 'no'}"

[gcode_macro SHOW_MSG]
gcode:
  {% set MSG = params.MSG|default("No msg")|string %}
  M117 {MSG}
  RESPOND MSG={'"%s"' % MSG}

[save_variables]
filename: ~/E3V2_data/klipper-variables.cfg

#For SHOW_MSG macro:
[respond]

#https://klipper.discourse.group/t/interruptible-heat-soak/1552/7

[gcode_macro _SET_FAN_SPEED]
gcode:
    M106 S{ (params.PERCENT | float) * 255 / 100 }


[gcode_macro CENTER]
gcode:
    G90
    G0 X{ printer.toolhead.axis_maximum.x/2 } Y{ printer.toolhead.axis_maximum.y/2 } Z{ printer.toolhead.axis_maximum.z/2 } F7200

[gcode_macro HEAT_SOAK]
description: heats the bed for a while

variable_target_temp: 0
variable_stage: None ## heating -> soaking -> done -> None

## in seconds
variable_check_interval: 10
variable_soak_time_remaining: 0
variable_total_time_elapsed: 0

gcode:
    {% set TARGET = params.TARGET | default(0) | float %}
    {% set DURATION = (params.DURATION | default(15) | int) * 60 %} ## minutes to seconds

    SET_GCODE_VARIABLE MACRO=HEAT_SOAK VARIABLE=target_temp         VALUE={ TARGET }
    SET_GCODE_VARIABLE MACRO=HEAT_SOAK VARIABLE=stage               VALUE="'heating'"
    SET_GCODE_VARIABLE MACRO=HEAT_SOAK VARIABLE=soak_time_remaining VALUE={ DURATION }
    SET_GCODE_VARIABLE MACRO=HEAT_SOAK VARIABLE=total_time_elapsed  VALUE=0

    ;; fire up the heater
    SET_HEATER_TEMPERATURE HEATER=heater_bed TARGET={ TARGET }

    ;; run the fan to circulate air
    _SET_FAN_SPEED PERCENT=50
    ;; put the bed and nozzle where they're a safe distance apart
    G28
    CENTER

    M84 ;; turn off steppers

    UPDATE_DELAYED_GCODE ID=heat_soaker DURATION={ check_interval }

    ;; pause the print during heat soak
    BASE_PAUSE

[gcode_macro CANCEL_HEAT_SOAK]
description: cancels an in-progress HEAT_SOAK cycle
gcode:
    SET_GCODE_VARIABLE MACRO=HEAT_SOAK VARIABLE=stage VALUE="'cancel'"
    UPDATE_DELAYED_GCODE ID=heat_soaker DURATION=1

[delayed_gcode heat_soaker]
; ## debug
; { action_respond_info( printer['gcode_macro HEAT_SOAK'] | tojson )}
gcode:
    {% set heat_soak = printer['gcode_macro HEAT_SOAK'] %}

    ## update total time elapsed
    {% set total_time_elapsed = heat_soak.total_time_elapsed + heat_soak.check_interval %}
    SET_GCODE_VARIABLE MACRO=HEAT_SOAK VARIABLE=total_time_elapsed VALUE={ total_time_elapsed }

    {% set stage = heat_soak.stage %}
    {% if stage == "heating" and printer.heater_bed.temperature >= heat_soak.target_temp %}
        {% set stage = "soaking" %}
    {% endif %}

    {% if stage == "soaking" %}
        ## update soak countdown
        {% set soak_time_remaining = [heat_soak.soak_time_remaining - heat_soak.check_interval, 0] | max %}
        SET_GCODE_VARIABLE MACRO=HEAT_SOAK VARIABLE=soak_time_remaining VALUE={ soak_time_remaining }

        {% if soak_time_remaining == 0 %}
            {% set stage = "done" %}
        {% endif %}
    {% endif %}

    SET_GCODE_VARIABLE MACRO=HEAT_SOAK VARIABLE=stage VALUE="'{ stage }'"

    {% if stage in ("done", "cancel") %}

        {% if stage == "cancel" %}
            {% set stage = "done" %}
            TURN_OFF_HEATERS
            M107 ; turn off fan

            M117 { "soak cancelled after ~%.1fm" | format(total_time_elapsed / 60.0) }

            ;; heat soak was cancelled -- also cancel the print
            CANCEL_PRINT
        {% else %}
            M117 { "soak complete after %.1fm" | format(total_time_elapsed / 60.0) }

            ;; heat soak is complete. Call the complete macro prior to starting the print
            SOAK_COMPLETE
            ;; resume / start the print
            BASE_RESUME
        {% endif %}

        ## reset all state vars, except stage, which may be queried via the api
        SET_GCODE_VARIABLE MACRO=HEAT_SOAK VARIABLE=target_temp         VALUE=0
        SET_GCODE_VARIABLE MACRO=HEAT_SOAK VARIABLE=soak_time_remaining VALUE=0
        SET_GCODE_VARIABLE MACRO=HEAT_SOAK VARIABLE=total_time_elapsed  VALUE=0

    {% else %}

        {% if total_time_elapsed % 90 == 0 %}
            ## output status periodically
            {% if stage == "heating" %}
                M117 { "heating -- %.1fm elapsed" | format(total_time_elapsed / 60.0) }
            {% elif stage == "soaking" %}
                M117 { "soaking -- %.1fm remaining" | format(soak_time_remaining / 60.0) }
            {% endif %}
        {% endif %}

        ## trigger ourselves again
        UPDATE_DELAYED_GCODE ID=heat_soaker DURATION={ heat_soak.check_interval }

        ## dwell for 1ms to prevent from going idle
        G4 P1

    {% endif %}

#*# <---------------------- SAVE_CONFIG ---------------------->
#*# DO NOT EDIT THIS BLOCK OR BELOW. The contents are auto-generated.
#*#
#*# [extruder]
#*# control = pid
#*# pid_kp = 18.614
#*# pid_ki = 0.816
#*# pid_kd = 106.100
#*#
#*# [heater_bed]
#*# control = pid
#*# pid_kp = 74.834
#*# pid_ki = 1.841
#*# pid_kd = 760.499
#*#
#*# [bltouch]
#*# z_offset = 1.925
#*#
#*# [input_shaper]
#*# shaper_type_x = mzv
#*# shaper_freq_x = 76.2
#*# shaper_type_y = mzv
#*# shaper_freq_y = 46.6
#*#
#*# [bed_mesh default]
#*# version = 1
#*# points =
#*# 	-0.027500, -0.115000, -0.130000, -0.240000, -0.225000
#*# 	0.057500, 0.000000, 0.010000, -0.125000, -0.120000
#*# 	0.052500, 0.010000, 0.010000, -0.087500, -0.097500
#*# 	0.107500, 0.022500, 0.002500, -0.067500, -0.105000
#*# 	-0.012500, -0.117500, -0.140000, -0.230000, -0.220000
#*# x_count = 5
#*# y_count = 5
#*# mesh_x_pps = 2
#*# mesh_y_pps = 2
#*# algo = bicubic
#*# tension = 0.2
#*# min_x = 47.5
#*# max_x = 207.74
#*# min_y = 32.15
#*# max_y = 183.79
